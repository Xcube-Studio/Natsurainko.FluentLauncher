using CommunityToolkit.Mvvm.SourceGenerators.Extensions;
using FluentLauncher.Infra.WinUI.SourceGenerators.Helpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FluentLauncher.Infra.WinUI.SourceGenerators.Notification;

[Generator(LanguageNames.CSharp)]
public class ExceptionNotificationGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var properties = context.SyntaxProvider.ForAttributeWithMetadataName(
            "FluentLauncher.Infra.UI.Notification.ExceptionNotificationAttribute",
            static (node, _) => node is MethodDeclarationSyntax { Parent: ClassDeclarationSyntax },
            static (ctx, token) =>
            {
                // Requires C# 13 partial properties
                if (!(((CSharpCompilation)ctx.SemanticModel.Compilation).LanguageVersion >= LanguageVersion.Preview))
                    return default;

                MethodDeclarationSyntax methodDeclarationSyntax = (MethodDeclarationSyntax)ctx.TargetNode;
                IMethodSymbol methodSymbol = (IMethodSymbol)ctx.TargetSymbol;

                // Extract class info
                INamedTypeSymbol namedTypeSymbol = methodSymbol.ContainingType;
                string @namespace = namedTypeSymbol.ContainingNamespace.ToDisplayString();
                string @class = namedTypeSymbol.Name;

                token.ThrowIfCancellationRequested();

                AttributeData attributeData = ctx.Attributes[0]; // does not allow multiple

                return ((@namespace, @class), (methodSymbol, attributeData));
            }
        );

        var groupedItems =
            properties.GroupBy(
                static item => item.Left,
                static item => item.Right
            );

        context.RegisterSourceOutput(groupedItems, static (ctx, item) =>
        {
            string @namespace = item.Key.@namespace;
            string @class = item.Key.@class;

            StringBuilder membersBuilder = new();

            foreach (var itemInfo in item.Right)
                GenerateItem(itemInfo, membersBuilder);

            ctx.AddSource($"{@namespace}.{@class}.g.cs", 
                $$"""
                // <auto-generated/>
                #pragma warning disable
                #nullable enable

                using System;

                using ExceptionNotification = global::Natsurainko.FluentLauncher.Services.UI.Notification.ExceptionNotification;
                using LocalizedStrings = global::Natsurainko.FluentLauncher.Utils.LocalizedStrings;

                namespace {{@namespace}}
                {
                    static partial class {{@class}}
                    {
                {{membersBuilder}}
                    }
                }
                """);
        });
    }

    private static void GenerateItem((IMethodSymbol, AttributeData) itemInfo, StringBuilder memberBuilder)
    {
        IMethodSymbol methodSymbol = itemInfo.Item1;

        if (!methodSymbol.IsExtensionMethod)
            return;

        Dictionary<string, string> properties = itemInfo.Item2.GetProperties();
        properties["Title"] = FormatString(properties["Title"]);
        properties.Add("Exception", "exception");

        if (properties.ContainsKey("Message"))
            properties["Message"] = FormatString(properties["Message"]);

        methodSymbol.GetExtensionParameter(out string firstParameterName);
        memberBuilder.Append(
        $$"""
                [global::System.CodeDom.Compiler.GeneratedCode("FluentLauncher.Infra.UI", "alpha")]
                public static partial void {{methodSymbol.Name}}({{methodSymbol.GetMethodParameters()}}) 
                {
                    {{firstParameterName}}.Show(new ExceptionNotification
                    {
                        {{string.Join(",\r\n                ", properties.Select(kvp => $"{kvp.Key} = {kvp.Value}"))}}
                    });
                }

        """);
    }

    private static string FormatString(string value)
    {
        if (value.StartsWith("Notifications__"))
            value = $"{{LocalizedStrings.{value}}}";
        if (value != "null")
            value = $"$\"{value}\"";

        return value;
    }
}
