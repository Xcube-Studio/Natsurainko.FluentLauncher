using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.ComponentModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using CommunityToolkit.Mvvm.SourceGenerators.Extensions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace FluentLauncher.Infra.Settings.SourceGenerators;

internal record struct SettingsContainerClassInfo(string Namespace, string ClassName);
internal record struct SettingItemInfo(
    string TypeName,
    string PropertyName,
    NullableAnnotation Nullability,
    AttributeData Attribute);

[Generator(LanguageNames.CSharp)]
public class SettingsItemSourceGenerator : IIncrementalGenerator
{
    public SettingsItemSourceGenerator()
    {
#if DEBUG
        if (!Debugger.IsAttached)
        {
            //Debugger.Launch();
        }
#endif
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var properties = context.SyntaxProvider.ForAttributeWithMetadataName(
            "FluentLauncher.Infra.Settings.SettingItemAttribute",
            static (node, _) => node is PropertyDeclarationSyntax { Parent: ClassDeclarationSyntax },
            static (ctx, token) =>
            {
                // Requires C# 13 partial properties
                if (!(((CSharpCompilation)ctx.SemanticModel.Compilation).LanguageVersion >= LanguageVersion.Preview))
                    return default;

                PropertyDeclarationSyntax propDeclaration = (PropertyDeclarationSyntax)ctx.TargetNode;
                IPropertySymbol propSymbol = (IPropertySymbol)ctx.TargetSymbol;

                // Extract class info
                INamedTypeSymbol settingsContainerClass = propSymbol.ContainingType;
                string containingNamespace = settingsContainerClass.ContainingNamespace.ToDisplayString();
                string className = settingsContainerClass.Name;
                SettingsContainerClassInfo classInfo = new(containingNamespace, className);

                token.ThrowIfCancellationRequested();
                // Extract property info
                AttributeData settingItemAttribute = ctx.Attributes[0]; // SettingItem does not allow multiple
                string propTypeName = propSymbol.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                if (propSymbol.Type.IsValueType && propTypeName.EndsWith("?")) // Get non-nullable type for value types
                    propTypeName = propTypeName.Substring(0, propTypeName.Length - 1);
                NullableAnnotation nullability = propSymbol.NullableAnnotation;
                string propName = propSymbol.Name;
                SettingItemInfo settingItemInfo = new(propTypeName, propName, nullability, settingItemAttribute);

                return (classInfo, settingItemInfo);
            }
        );

        var groupedItems =
            properties.GroupBy(
                static item=>item.Left,
                static item=>item.Right
            );

        context.RegisterSourceOutput(groupedItems, static (ctx, item) =>
        {
            var classInfo = item.Key;
            var itemInfos = item.Right;

            string namespaceName = classInfo.Namespace;
            string className = classInfo.ClassName;
            var filename = $"{namespaceName}.{className}.g.cs";

            StringBuilder membersBuilder = new();
            foreach (var itemInfo in itemInfos)
            {
                GenerateSettingItem(itemInfo, membersBuilder);
            }

            var source = $$"""
                                // <auto-generated/>
                                #pragma warning disable
                                #nullable enable
                                namespace {{namespaceName}}
                                {
                                    partial class {{className}}
                                    {
                                {{membersBuilder}}

                                //        protected override void InitializeContainers()
                                //        {
                                //initBuilder
                                //        }
                                    }
                                }
                                """;

            ctx.AddSource(filename, source);
        });
    }

    private static void GenerateSettingItem(SettingItemInfo settingItemInfo, StringBuilder memberBuilder)
    {
        AttributeData attribute = settingItemInfo.Attribute;

        string defaultValue = "";
        string converter = "";
        string sourceTypeName = "";

        // Parse default value and converter
        foreach(var item in attribute.NamedArguments)
        {
            if (item.Key == "Default")
            {
                defaultValue = $", {item.Value.ToCSharpString()}";
            }
            else if (item.Key == "Converter")
            {
                if (item.Value.Value is not ITypeSymbol converterType)
                    continue;
                INamedTypeSymbol? interfaceType = converterType.Interfaces.FirstOrDefault(syn => syn.Name.Contains("IDataTypeConverter"));
                if (interfaceType is null) continue;
                ITypeSymbol sourceType = interfaceType.TypeArguments[0];

                sourceTypeName = $", {sourceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}";
                converter = $", global::{item.Value.Value}.Instance";
            }
        }

        // If default value is not provided, the property is nullable
        string propTypeName = settingItemInfo.TypeName;
        string propIdentifierName = settingItemInfo.PropertyName;
        string nullable = settingItemInfo.Nullability == NullableAnnotation.Annotated ? "?" : "";

        memberBuilder.Append($$"""
                        public partial {{propTypeName}}{{nullable}} {{propIdentifierName}}
                        {
                            get => GetValue<{{propTypeName}}{{sourceTypeName}}>(nameof({{propIdentifierName}}){{defaultValue}}{{converter}});
                            set => SetValue<{{propTypeName}}{{sourceTypeName}}>(nameof({{propIdentifierName}}), value, {{propIdentifierName}}Changed{{converter}});
                        }

                        public event global::FluentLauncher.Infra.Settings.SettingChangedEventHandler? {{propIdentifierName}}Changed;


                """);
    }
}
