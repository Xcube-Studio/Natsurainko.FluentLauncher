using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;

namespace AppSettingsManagement.SourceGenerators;

[Generator(LanguageNames.CSharp)]
public class SettingsViewModelGenerator : ISourceGenerator
{
    public SettingsViewModelGenerator()
    {
#if DEBUG
        if (!Debugger.IsAttached)
        {
            //Debugger.Launch();
        }
#endif
    }

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SettingsViewModelSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not SettingsViewModelSyntaxReceiver receiver)
            return;

        foreach (var classDeclaration in receiver.CandidateClasses)
        {
            var model = new SettingsViewModelInformation(classDeclaration, context);

            var initBuilder = new StringBuilder();
            var propertyChangedBuilder = new StringBuilder();
            var finalizerBuilder = new StringBuilder();

            foreach (var member in model.BindToSettingMembers)
            {
                if (member.Type.StartsWith("ObservableCollection"))
                    GenerateCollection(member, initBuilder, propertyChangedBuilder, finalizerBuilder);
                else
                    GenerateSettingitem(member, initBuilder, propertyChangedBuilder, finalizerBuilder);
            }

            var source = $$"""
                // <auto-generated/>
                #pragma warning disable
                #nullable enable

                using System.CodeDom.Compiler;
                using ISettingsViewModel = global::AppSettingsManagement.Mvvm.ISettingsViewModel;
                using SettingChangedEventHandler = global::AppSettingsManagement.SettingChangedEventHandler;
                using PropertyChangedEventArgs = global::System.ComponentModel.PropertyChangedEventArgs;
                using SettingsService = {{model.SettingsProviderClassFullName}};

                namespace {{model.Namespace}}
                {
                    partial class {{model.ClassName}}
                    {
                        [GeneratedCode("AppSettingsManagement", "alpha")]
                        global::AppSettingsManagement.SettingsContainer ISettingsViewModel.SettingsContainer => {{model.SettingsProviderMemberName}};

                        [GeneratedCode("AppSettingsManagement", "alpha")]
                        global::System.Collections.Generic.Dictionary<string, SettingChangedEventHandler> ISettingsViewModel.SettingChangedEventHandlers { get; } = new();

                        /// <inheritdoc/>
                        [GeneratedCode("AppSettingsManagement", "alpha")]
                        void ISettingsViewModel.InitializeSettings()
                        {
                            SettingsService container = {{model.SettingsProviderMemberName}};
                            global::System.WeakReference<global::{{model.Namespace}}.{{model.ClassName}}> weakref = new(this);
                            global::System.Collections.Generic.Dictionary<string, SettingChangedEventHandler> handlers = ((ISettingsViewModel)this).SettingChangedEventHandlers;

                {{initBuilder.ToString()}}

                            PropertyChanged += ((ISettingsViewModel)this).SettingsViewModelPropertyChangedCallback;
                        }

                        /// <inheritdoc/>
                        [GeneratedCode("AppSettingsManagement", "alpha")]
                        void ISettingsViewModel.SettingsViewModelPropertyChangedCallback(object? sender, PropertyChangedEventArgs e)
                        {
                            SettingsService container = {{model.SettingsProviderMemberName}};
                            switch (e.PropertyName)
                            {
                {{propertyChangedBuilder.ToString()}}
                                default: break;
                            }
                        }

                        /// <inheritdoc/>
                        [GeneratedCode("AppSettingsManagement", "alpha")]
                        void ISettingsViewModel.RemoveSettingsChagnedHandlers()
                        {
                            SettingsService container = {{model.SettingsProviderMemberName}};
                            global::System.Collections.Generic.Dictionary<string, SettingChangedEventHandler> handlers = ((ISettingsViewModel)this).SettingChangedEventHandlers;

                {{finalizerBuilder.ToString()}}
                        }
                    }
                }
                """;

            context.AddSource($"{model.Namespace}.{model.ClassName}.g.cs", source);
        }
    }

    private void GenerateSettingitem(
        (string Name, string Path, string Type) member,
        StringBuilder initBuilder, StringBuilder propertyChangedBuilder, StringBuilder finalizerBuilder)
    {
        initBuilder.Append($$"""
                            // Register: {{member.Path.Replace('/', '.')}}Changed
                            {{member.Name}} = container.{{member.Path.Replace('/', '.')}};
                            SettingChangedEventHandler {{member.Name}}ChangedHandler = (sender, e) =>
                            {
                                if (weakref.TryGetTarget(out var target))
                                    target.{{member.Name}} = container.{{member.Path.Replace('/', '.')}};
                            };
                            container.{{member.Path.Replace('/', '.')}}Changed += {{member.Name}}ChangedHandler;
                            handlers["{{member.Path}}"] = {{member.Name}}ChangedHandler;


            """);

        propertyChangedBuilder.Append($$"""
                            case nameof({{member.Name}}):
                                container.{{member.Path.Replace('/', '.')}} = {{member.Name}}; break;

            """);

        finalizerBuilder.Append($$"""
                        container.{{member.Path.Replace('/', '.')}}Changed -= handlers["{{member.Path}}"];

            """);
    }

    private void GenerateCollection(
        (string Name, string Path, string Type) member,
        StringBuilder initBuilder, StringBuilder propertyChangedBuilder, StringBuilder finalizerBuilder)
    {
        initBuilder.Append($$"""
                            // Init: {{member.Name}}
                            {{member.Name}} = container.{{member.Path.Replace('/', '.')}};

            """);
    }
}

public class SettingsViewModelSyntaxReceiver : ISyntaxReceiver
{
    public List<ClassDeclarationSyntax> CandidateClasses { get; } = new();

    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
    {
        if (syntaxNode is ClassDeclarationSyntax classDeclaration &&
            classDeclaration.BaseList?.Types.Any(type => type.ToString() == "ISettingsViewModel") == true)
        {
            CandidateClasses.Add(classDeclaration);
        }
    }
}


public class SettingsViewModelInformation
{
    public string Namespace { get; set; }
    public string ClassName { get; }
    public string SettingsProviderClassFullName { get; }
    public string SettingsProviderMemberName { get; }
    public List<(string Name, string Path, string Type)> BindToSettingMembers { get; } = new();

    public SettingsViewModelInformation(ClassDeclarationSyntax classDeclaration, GeneratorExecutionContext context)
    {
        var semanticModel = context.Compilation.GetSemanticModel(classDeclaration.SyntaxTree);
        
        var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration);
        Namespace = classSymbol.ContainingNamespace.ToDisplayString();
        ClassName = classDeclaration.Identifier.ValueText;

        // Find the name of the member with [SettingsProvider] attribute
        var settingsProviderSyntax = 
            classDeclaration.Members.Where(member => member.AttributeLists
                .SelectMany(a => a.Attributes)
                .Any(a => a.Name.ToString().StartsWith("SettingsProvider"))
            ).FirstOrDefault();

        // If contains multiple [SettingsProvider], the first is taken.
        if (settingsProviderSyntax is not FieldDeclarationSyntax settingsProviderDeclSyntax)
            return;

        // Get settings provider namespace and type name
        var settingsProviderFieldSymbol = semanticModel.GetDeclaredSymbol(settingsProviderDeclSyntax.Declaration.Variables.First()) as IFieldSymbol;
        SettingsProviderMemberName = settingsProviderFieldSymbol.Name;
        SettingsProviderClassFullName = $"global::{settingsProviderFieldSymbol.Type.ContainingNamespace}.{settingsProviderFieldSymbol.Type.Name}";

        // Extract setting binding information
        foreach (var member in classDeclaration.Members)
        {
            // Restrict to members with [BindToSetting] property
            var bindToSettingAttribute = member.AttributeLists
                .SelectMany(a => a.Attributes)
                .FirstOrDefault(a => a.Name.ToString().StartsWith("BindToSetting"));

            if (bindToSettingAttribute is null)
                continue;

            // Get member name and type
            var memberName = member switch
            {
                FieldDeclarationSyntax fieldDeclarationSyntax => fieldDeclarationSyntax.Declaration.Variables.First().Identifier.ValueText,
                PropertyDeclarationSyntax propertyDeclaractionSyntax => propertyDeclaractionSyntax.Identifier.ValueText,
                _ => throw new NotSupportedException()
            };

            var type = member switch
            {
                FieldDeclarationSyntax fieldDeclarationSyntax => fieldDeclarationSyntax.Declaration.Type.ToString(),
                PropertyDeclarationSyntax propertyDeclaractionSyntax => propertyDeclaractionSyntax.Type.ToString(),
                _ => throw new NotSupportedException()
            };

            // Get binding path
            var pathArgument = bindToSettingAttribute.ArgumentList?.Arguments
                .FirstOrDefault(a => a.NameEquals?.Name.Identifier.ValueText == "Path");

            if (pathArgument is null)
                continue;

            // Get path by evaluating the argument const expression
            Optional<object> pathExpressionValue = semanticModel.GetConstantValue(pathArgument.Expression);
            var path = pathExpressionValue.HasValue ? (string)pathExpressionValue.Value : "";

            // Add to list
            if (!type.StartsWith("ObservableCollection"))
                memberName = GetPublicPropertyName(memberName);

            var bindingEntry = (memberName, path, type);
            BindToSettingMembers.Add(bindingEntry);
        }

        string GetPublicPropertyName(string fieldName)
        {
            if (fieldName.StartsWith("_"))
                fieldName = fieldName.Substring(1);

            if (fieldName.Length == 0)
                return "";

            // Convert to public property generated by MVVM toolkit
            var chars = fieldName.ToCharArray();
            chars[0] = char.ToUpper(chars[0]);
            return new string(chars);
        }
    }
}
