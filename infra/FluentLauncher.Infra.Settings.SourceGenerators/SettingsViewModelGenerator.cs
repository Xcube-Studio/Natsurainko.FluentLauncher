using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Text;

namespace FluentLauncher.Infra.Settings.SourceGenerators;

[Generator(LanguageNames.CSharp)]
public class SettingsViewModelGenerator : IIncrementalGenerator
{
    public SettingsViewModelGenerator()
    {
#if DEBUG
        if (!Debugger.IsAttached)
        {
            //Debugger.Launch();
        }
#endif
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var settingViewModels = context.SyntaxProvider.CreateSyntaxProvider(
            static (node, _) =>
            {
                return node is ClassDeclarationSyntax classDeclaration
                    && classDeclaration.BaseList?.Types.Any(type => type.ToString() == "ISettingsViewModel") == true;
            },
            static (ctx, token) =>
            {
                // TODO: Optimize data structure using struct/record for caching in the pipeline
                return new SettingsViewModelInformation((ClassDeclarationSyntax)ctx.Node, ctx.SemanticModel);
            }
        );

        var source = settingViewModels.Select(
            (vm, _) =>
            {
                string src = Execute.GetSource(vm);
                string filename = $"{vm.Namespace}.{vm.ClassName}.g.cs";
                return (filename, src);
            }
        );

        context.RegisterSourceOutput(source, (ctx, data) =>
        {
            ctx.AddSource(data.filename, data.src);
        });
    }
}

file static class Execute
{
    public static string GetSource(SettingsViewModelInformation model)
    {
        var initBuilder = new StringBuilder();
        var propertyChangedBuilder = new StringBuilder();
        var finalizerBuilder = new StringBuilder();

        foreach (var member in model.BindToSettingMembers)
        {
            if (member.Type.StartsWith("ObservableCollection"))
                GenerateCollection(member, initBuilder, propertyChangedBuilder, finalizerBuilder);
            else
                GenerateSettingitem(member, initBuilder, propertyChangedBuilder, finalizerBuilder);
        }

        var source = $$"""
            // <auto-generated/>
            #pragma warning disable
            #nullable enable

            using System.CodeDom.Compiler;
            using ISettingsViewModel = global::FluentLauncher.Infra.Settings.Mvvm.ISettingsViewModel;
            using SettingChangedEventHandler = global::FluentLauncher.Infra.Settings.SettingChangedEventHandler;
            using PropertyChangedEventArgs = global::System.ComponentModel.PropertyChangedEventArgs;
            using SettingsService = {{model.SettingsProviderClassFullName}};

            namespace {{model.Namespace}}
            {
                partial class {{model.ClassName}}
                {
                    [GeneratedCode("FluentLauncher.Infra.Settings", "alpha")]
                    global::FluentLauncher.Infra.Settings.SettingsContainer ISettingsViewModel.SettingsContainer => {{model.SettingsProviderMemberName}};

                    [GeneratedCode("FluentLauncher.Infra.Settings", "alpha")]
                    global::System.Collections.Generic.Dictionary<string, SettingChangedEventHandler> ISettingsViewModel.SettingChangedEventHandlers { get; } = new();

                    /// <inheritdoc/>
                    [GeneratedCode("FluentLauncher.Infra.Settings", "alpha")]
                    void ISettingsViewModel.InitializeSettings()
                    {
                        SettingsService container = {{model.SettingsProviderMemberName}};
                        global::System.WeakReference<global::{{model.Namespace}}.{{model.ClassName}}> weakref = new(this);
                        global::System.Collections.Generic.Dictionary<string, SettingChangedEventHandler> handlers = ((ISettingsViewModel)this).SettingChangedEventHandlers;

            {{initBuilder.ToString()}}

                        PropertyChanged += ((ISettingsViewModel)this).SettingsViewModelPropertyChangedCallback;
                    }

                    /// <inheritdoc/>
                    [GeneratedCode("FluentLauncher.Infra.Settings", "alpha")]
                    void ISettingsViewModel.SettingsViewModelPropertyChangedCallback(object? sender, PropertyChangedEventArgs e)
                    {
                        SettingsService container = {{model.SettingsProviderMemberName}};
                        switch (e.PropertyName)
                        {
            {{propertyChangedBuilder.ToString()}}
                            default: break;
                        }
                    }

                    /// <inheritdoc/>
                    [GeneratedCode("FluentLauncher.Infra.Settings", "alpha")]
                    void ISettingsViewModel.RemoveSettingsChagnedHandlers()
                    {
                        SettingsService container = {{model.SettingsProviderMemberName}};
                        global::System.Collections.Generic.Dictionary<string, SettingChangedEventHandler> handlers = ((ISettingsViewModel)this).SettingChangedEventHandlers;

            {{finalizerBuilder.ToString()}}
                    }
                }
            }
            """;

        return source;
    }

    private static void GenerateSettingitem(
        (string Name, string Path, string Type) member,
        StringBuilder initBuilder, StringBuilder propertyChangedBuilder, StringBuilder finalizerBuilder)
    {
        initBuilder.Append($$"""
                            // Register: {{member.Path.Replace('/', '.')}}Changed
                            {{member.Name}} = container.{{member.Path.Replace('/', '.')}};
                            SettingChangedEventHandler {{member.Name}}ChangedHandler = (sender, e) =>
                            {
                                if (weakref.TryGetTarget(out var target))
                                    target.{{member.Name}} = container.{{member.Path.Replace('/', '.')}};
                            };
                            container.{{member.Path.Replace('/', '.')}}Changed += {{member.Name}}ChangedHandler;
                            handlers["{{member.Path}}"] = {{member.Name}}ChangedHandler;


            """);

        propertyChangedBuilder.Append($$"""
                            case nameof({{member.Name}}):
                                container.{{member.Path.Replace('/', '.')}} = {{member.Name}}; break;

            """);

        finalizerBuilder.Append($$"""
                        container.{{member.Path.Replace('/', '.')}}Changed -= handlers["{{member.Path}}"];

            """);
    }

    private static void GenerateCollection(
        (string Name, string Path, string Type) member,
        StringBuilder initBuilder, StringBuilder propertyChangedBuilder, StringBuilder finalizerBuilder)
    {
        initBuilder.Append($$"""
                            // Init: {{member.Name}}
                            {{member.Name}} = container.{{member.Path.Replace('/', '.')}};

            """);
    }
}

public class SettingsViewModelInformation
{
    public string Namespace { get; set; }
    public string ClassName { get; }
    public string SettingsProviderClassFullName { get; }
    public string SettingsProviderMemberName { get; }
    public List<(string Name, string Path, string Type)> BindToSettingMembers { get; } = new();

    public SettingsViewModelInformation(ClassDeclarationSyntax classDeclaration, SemanticModel semanticModel)
    {
        var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration);
        Namespace = classSymbol.ContainingNamespace.ToDisplayString();
        ClassName = classDeclaration.Identifier.ValueText;

        // Find the name of the member with [SettingsProvider] attribute
        var settingsProviderSyntax =
            classDeclaration.Members.Where(member => member.AttributeLists
                .SelectMany(a => a.Attributes)
                .Any(a => a.Name.ToString().StartsWith("SettingsProvider"))
            ).FirstOrDefault();

        // If contains multiple [SettingsProvider], the first is taken.
        if (settingsProviderSyntax is not FieldDeclarationSyntax settingsProviderDeclSyntax)
            return;

        // Get settings provider namespace and type name
        var settingsProviderFieldSymbol = semanticModel.GetDeclaredSymbol(settingsProviderDeclSyntax.Declaration.Variables.First()) as IFieldSymbol;
        SettingsProviderMemberName = settingsProviderFieldSymbol.Name;
        SettingsProviderClassFullName = $"global::{settingsProviderFieldSymbol.Type.ContainingNamespace}.{settingsProviderFieldSymbol.Type.Name}";

        // Extract setting binding information
        foreach (var member in classDeclaration.Members)
        {
            // Restrict to members with [BindToSetting] property
            var bindToSettingAttribute = member.AttributeLists
                .SelectMany(a => a.Attributes)
                .FirstOrDefault(a => a.Name.ToString().StartsWith("BindToSetting"));

            if (bindToSettingAttribute is null)
                continue;

            // Get member name and type
            var memberName = member switch
            {
                FieldDeclarationSyntax fieldDeclarationSyntax => fieldDeclarationSyntax.Declaration.Variables.First().Identifier.ValueText,
                PropertyDeclarationSyntax propertyDeclaractionSyntax => propertyDeclaractionSyntax.Identifier.ValueText,
                _ => throw new NotSupportedException()
            };

            var type = member switch
            {
                FieldDeclarationSyntax fieldDeclarationSyntax => fieldDeclarationSyntax.Declaration.Type.ToString(),
                PropertyDeclarationSyntax propertyDeclaractionSyntax => propertyDeclaractionSyntax.Type.ToString(),
                _ => throw new NotSupportedException()
            };

            // Get binding path
            var pathArgument = bindToSettingAttribute.ArgumentList?.Arguments
                .FirstOrDefault(a => a.NameEquals?.Name.Identifier.ValueText == "Path");

            if (pathArgument is null)
                continue;

            // Get path by evaluating the argument const expression
            Optional<object> pathExpressionValue = semanticModel.GetConstantValue(pathArgument.Expression);
            var path = pathExpressionValue.HasValue ? (string)pathExpressionValue.Value : "";

            // Add to list
            if (!type.StartsWith("ObservableCollection"))
                memberName = GetPublicPropertyName(memberName);

            var bindingEntry = (memberName, path, type);
            BindToSettingMembers.Add(bindingEntry);
        }

        string GetPublicPropertyName(string fieldName)
        {
            if (fieldName.StartsWith("_"))
                fieldName = fieldName.Substring(1);

            if (fieldName.Length == 0)
                return "";

            // Convert to public property generated by MVVM toolkit
            var chars = fieldName.ToCharArray();
            chars[0] = char.ToUpper(chars[0]);
            return new string(chars);
        }
    }
}
